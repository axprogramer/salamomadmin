import {
  __commonJS,
  __require
} from "./chunk-BYPFWIQ6.js";

// node_modules/fast-diff/diff.js
var require_diff = __commonJS({
  "node_modules/fast-diff/diff.js"(exports, module) {
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text2, cursor_pos, cleanup, _fix_unicode) {
      if (text1 === text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      if (cursor_pos != null) {
        var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
        if (editdiff) {
          return editdiff;
        }
      }
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = diff_compute_(text1, text2);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs, _fix_unicode);
      if (cleanup) {
        diff_cleanupSemantic(diffs);
      }
      return diffs;
    }
    function diff_compute_(text1, text2) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text2]];
      }
      if (!text2) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i !== -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i + shorttext.length)]
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length === 1) {
        return [
          [DIFF_DELETE, text1],
          [DIFF_INSERT, text2]
        ];
      }
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text2);
    }
    function diff_bisect_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 !== 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      return [
        [DIFF_DELETE, text1],
        [DIFF_INSERT, text2]
      ];
    }
    function diff_bisectSplit_(text1, text2, x, y) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    function diff_commonPrefix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_commonOverlap_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      if (text1_length == 0 || text2_length == 0) {
        return 0;
      }
      if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
      } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
      }
      var text_length = Math.min(text1_length, text2_length);
      if (text1 == text2) {
        return text_length;
      }
      var best = 0;
      var length = 1;
      while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
          return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
          best = length;
          length++;
        }
      }
    }
    function diff_commonSuffix(text1, text2) {
      if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
          var prefixLength = diff_commonPrefix(
            longtext2.substring(i),
            shorttext2.substring(j)
          );
          var suffixLength = diff_commonSuffix(
            longtext2.substring(0, i),
            shorttext2.substring(0, j)
          );
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 4)
      );
      var hm2 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 2)
      );
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    function diff_cleanupSemantic(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastequality = null;
      var pointer = 0;
      var length_insertions1 = 0;
      var length_deletions1 = 0;
      var length_insertions2 = 0;
      var length_deletions2 = 0;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          equalities[equalitiesLength++] = pointer;
          length_insertions1 = length_insertions2;
          length_deletions1 = length_deletions2;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastequality = diffs[pointer][1];
        } else {
          if (diffs[pointer][0] == DIFF_INSERT) {
            length_insertions2 += diffs[pointer][1].length;
          } else {
            length_deletions2 += diffs[pointer][1].length;
          }
          if (lastequality && lastequality.length <= Math.max(length_insertions1, length_deletions1) && lastequality.length <= Math.max(length_insertions2, length_deletions2)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, [
              DIFF_DELETE,
              lastequality
            ]);
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            length_insertions1 = 0;
            length_deletions1 = 0;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastequality = null;
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs);
      }
      diff_cleanupSemanticLossless(diffs);
      pointer = 1;
      while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
          var deletion = diffs[pointer - 1][1];
          var insertion = diffs[pointer][1];
          var overlap_length1 = diff_commonOverlap_(deletion, insertion);
          var overlap_length2 = diff_commonOverlap_(insertion, deletion);
          if (overlap_length1 >= overlap_length2) {
            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
              diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                insertion.substring(0, overlap_length1)
              ]);
              diffs[pointer - 1][1] = deletion.substring(
                0,
                deletion.length - overlap_length1
              );
              diffs[pointer + 1][1] = insertion.substring(overlap_length1);
              pointer++;
            }
          } else {
            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
              diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                deletion.substring(0, overlap_length2)
              ]);
              diffs[pointer - 1][0] = DIFF_INSERT;
              diffs[pointer - 1][1] = insertion.substring(
                0,
                insertion.length - overlap_length2
              );
              diffs[pointer + 1][0] = DIFF_DELETE;
              diffs[pointer + 1][1] = deletion.substring(overlap_length2);
              pointer++;
            }
          }
          pointer++;
        }
        pointer++;
      }
    }
    var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    var whitespaceRegex_ = /\s/;
    var linebreakRegex_ = /[\r\n]/;
    var blanklineEndRegex_ = /\n\r?\n$/;
    var blanklineStartRegex_ = /^\r?\n\r?\n/;
    function diff_cleanupSemanticLossless(diffs) {
      function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
          return 6;
        }
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
          return 5;
        } else if (lineBreak1 || lineBreak2) {
          return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
          return 3;
        } else if (whitespace1 || whitespace2) {
          return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
          return 1;
        }
        return 0;
      }
      var pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          var equality1 = diffs[pointer - 1][1];
          var edit = diffs[pointer][1];
          var equality2 = diffs[pointer + 1][1];
          var commonOffset = diff_commonSuffix(equality1, edit);
          if (commonOffset) {
            var commonString = edit.substring(edit.length - commonOffset);
            equality1 = equality1.substring(0, equality1.length - commonOffset);
            edit = commonString + edit.substring(0, edit.length - commonOffset);
            equality2 = commonString + equality2;
          }
          var bestEquality1 = equality1;
          var bestEdit = edit;
          var bestEquality2 = equality2;
          var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          while (edit.charAt(0) === equality2.charAt(0)) {
            equality1 += edit.charAt(0);
            edit = edit.substring(1) + equality2.charAt(0);
            equality2 = equality2.substring(1);
            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            if (score >= bestScore) {
              bestScore = score;
              bestEquality1 = equality1;
              bestEdit = edit;
              bestEquality2 = equality2;
            }
          }
          if (diffs[pointer - 1][1] != bestEquality1) {
            if (bestEquality1) {
              diffs[pointer - 1][1] = bestEquality1;
            } else {
              diffs.splice(pointer - 1, 1);
              pointer--;
            }
            diffs[pointer][1] = bestEdit;
            if (bestEquality2) {
              diffs[pointer + 1][1] = bestEquality2;
            } else {
              diffs.splice(pointer + 1, 1);
              pointer--;
            }
          }
        }
        pointer++;
      }
    }
    function diff_cleanupMerge(diffs, fix_unicode) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          diffs.splice(pointer, 1);
          continue;
        }
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            var previous_equality = pointer - count_insert - count_delete - 1;
            if (fix_unicode) {
              if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                var stray = diffs[previous_equality][1].slice(-1);
                diffs[previous_equality][1] = diffs[previous_equality][1].slice(
                  0,
                  -1
                );
                text_delete = stray + text_delete;
                text_insert = stray + text_insert;
                if (!diffs[previous_equality][1]) {
                  diffs.splice(previous_equality, 1);
                  pointer--;
                  var k = previous_equality - 1;
                  if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                    count_insert++;
                    text_insert = diffs[k][1] + text_insert;
                    k--;
                  }
                  if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                    count_delete++;
                    text_delete = diffs[k][1] + text_delete;
                    k--;
                  }
                  previous_equality = k;
                }
              }
              if (starts_with_pair_end(diffs[pointer][1])) {
                var stray = diffs[pointer][1].charAt(0);
                diffs[pointer][1] = diffs[pointer][1].slice(1);
                text_delete += stray;
                text_insert += stray;
              }
            }
            if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
              diffs.splice(pointer, 1);
              break;
            }
            if (text_delete.length > 0 || text_insert.length > 0) {
              if (text_delete.length > 0 && text_insert.length > 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (previous_equality >= 0) {
                    diffs[previous_equality][1] += text_insert.substring(
                      0,
                      commonlength
                    );
                  } else {
                    diffs.splice(0, 0, [
                      DIFF_EQUAL,
                      text_insert.substring(0, commonlength)
                    ]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(
                    0,
                    text_insert.length - commonlength
                  );
                  text_delete = text_delete.substring(
                    0,
                    text_delete.length - commonlength
                  );
                }
              }
              var n = count_insert + count_delete;
              if (text_delete.length === 0 && text_insert.length === 0) {
                diffs.splice(pointer - n, n);
                pointer = pointer - n;
              } else if (text_delete.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 1;
              } else if (text_insert.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
                pointer = pointer - n + 1;
              } else {
                diffs.splice(
                  pointer - n,
                  n,
                  [DIFF_DELETE, text_delete],
                  [DIFF_INSERT, text_insert]
                );
                pointer = pointer - n + 2;
              }
            }
            if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
          if (diffs[pointer][1].substring(
            diffs[pointer][1].length - diffs[pointer - 1][1].length
          ) === diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(
              0,
              diffs[pointer][1].length - diffs[pointer - 1][1].length
            );
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs, fix_unicode);
      }
    }
    function is_surrogate_pair_start(charCode) {
      return charCode >= 55296 && charCode <= 56319;
    }
    function is_surrogate_pair_end(charCode) {
      return charCode >= 56320 && charCode <= 57343;
    }
    function starts_with_pair_end(str) {
      return is_surrogate_pair_end(str.charCodeAt(0));
    }
    function ends_with_pair_start(str) {
      return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
    }
    function remove_empty_tuples(tuples) {
      var ret = [];
      for (var i = 0; i < tuples.length; i++) {
        if (tuples[i][1].length > 0) {
          ret.push(tuples[i]);
        }
      }
      return ret;
    }
    function make_edit_splice(before, oldMiddle, newMiddle, after) {
      if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
        return null;
      }
      return remove_empty_tuples([
        [DIFF_EQUAL, before],
        [DIFF_DELETE, oldMiddle],
        [DIFF_INSERT, newMiddle],
        [DIFF_EQUAL, after]
      ]);
    }
    function find_cursor_edit_diff(oldText, newText, cursor_pos) {
      var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
      var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
      var oldLength = oldText.length;
      var newLength = newText.length;
      if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
        var oldCursor = oldRange.index;
        var oldBefore = oldText.slice(0, oldCursor);
        var oldAfter = oldText.slice(oldCursor);
        var maybeNewCursor = newRange ? newRange.index : null;
        editBefore: {
          var newCursor = oldCursor + newLength - oldLength;
          if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
            break editBefore;
          }
          if (newCursor < 0 || newCursor > newLength) {
            break editBefore;
          }
          var newBefore = newText.slice(0, newCursor);
          var newAfter = newText.slice(newCursor);
          if (newAfter !== oldAfter) {
            break editBefore;
          }
          var prefixLength = Math.min(oldCursor, newCursor);
          var oldPrefix = oldBefore.slice(0, prefixLength);
          var newPrefix = newBefore.slice(0, prefixLength);
          if (oldPrefix !== newPrefix) {
            break editBefore;
          }
          var oldMiddle = oldBefore.slice(prefixLength);
          var newMiddle = newBefore.slice(prefixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
        }
        editAfter: {
          if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
            break editAfter;
          }
          var cursor = oldCursor;
          var newBefore = newText.slice(0, cursor);
          var newAfter = newText.slice(cursor);
          if (newBefore !== oldBefore) {
            break editAfter;
          }
          var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
          var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
          var newSuffix = newAfter.slice(newAfter.length - suffixLength);
          if (oldSuffix !== newSuffix) {
            break editAfter;
          }
          var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
          var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
          return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
        }
      }
      if (oldRange.length > 0 && newRange && newRange.length === 0) {
        replaceRange: {
          var oldPrefix = oldText.slice(0, oldRange.index);
          var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
          var prefixLength = oldPrefix.length;
          var suffixLength = oldSuffix.length;
          if (newLength < prefixLength + suffixLength) {
            break replaceRange;
          }
          var newPrefix = newText.slice(0, prefixLength);
          var newSuffix = newText.slice(newLength - suffixLength);
          if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
            break replaceRange;
          }
          var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
          var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
        }
      }
      return null;
    }
    function diff(text1, text2, cursor_pos, cleanup) {
      return diff_main(text1, text2, cursor_pos, cleanup, true);
    }
    diff.INSERT = DIFF_INSERT;
    diff.DELETE = DIFF_DELETE;
    diff.EQUAL = DIFF_EQUAL;
    module.exports = diff;
  }
});

// node_modules/prettier-linter-helpers/index.js
var require_prettier_linter_helpers = __commonJS({
  "node_modules/prettier-linter-helpers/index.js"(exports, module) {
    var diff = require_diff();
    var LINE_ENDING_RE = /\r\n|[\r\n\u2028\u2029]/;
    function showInvisibles(str) {
      let ret = "";
      for (let i = 0; i < str.length; i++) {
        switch (str[i]) {
          case " ":
            ret += "·";
            break;
          case "\n":
            ret += "⏎";
            break;
          case "	":
            ret += "↹";
            break;
          case "\r":
            ret += "␍";
            break;
          default:
            ret += str[i];
            break;
        }
      }
      return ret;
    }
    function generateDifferences(source, prettierSource) {
      const results = diff(source, prettierSource);
      const differences = [];
      const batch = [];
      let offset = 0;
      while (results.length) {
        const result = results.shift();
        const op = result[0];
        const text = result[1];
        switch (op) {
          case diff.INSERT:
          case diff.DELETE:
            batch.push(result);
            break;
          case diff.EQUAL:
            if (results.length) {
              if (batch.length) {
                if (LINE_ENDING_RE.test(text)) {
                  flush();
                  offset += text.length;
                } else {
                  batch.push(result);
                }
              } else {
                offset += text.length;
              }
            }
            break;
          default:
            throw new Error(`Unexpected fast-diff operation "${op}"`);
        }
        if (batch.length && !results.length) {
          flush();
        }
      }
      return differences;
      function flush() {
        let aheadDeleteText = "";
        let aheadInsertText = "";
        while (batch.length) {
          const next = batch.shift();
          const op = next[0];
          const text = next[1];
          switch (op) {
            case diff.INSERT:
              aheadInsertText += text;
              break;
            case diff.DELETE:
              aheadDeleteText += text;
              break;
            case diff.EQUAL:
              aheadDeleteText += text;
              aheadInsertText += text;
              break;
          }
        }
        if (aheadDeleteText && aheadInsertText) {
          differences.push({
            offset,
            operation: generateDifferences.REPLACE,
            insertText: aheadInsertText,
            deleteText: aheadDeleteText
          });
        } else if (!aheadDeleteText && aheadInsertText) {
          differences.push({
            offset,
            operation: generateDifferences.INSERT,
            insertText: aheadInsertText
          });
        } else if (aheadDeleteText && !aheadInsertText) {
          differences.push({
            offset,
            operation: generateDifferences.DELETE,
            deleteText: aheadDeleteText
          });
        }
        offset += aheadDeleteText.length;
      }
    }
    generateDifferences.INSERT = "insert";
    generateDifferences.DELETE = "delete";
    generateDifferences.REPLACE = "replace";
    module.exports = {
      showInvisibles,
      generateDifferences
    };
  }
});

// node_modules/eslint-plugin-prettier/package.json
var require_package = __commonJS({
  "node_modules/eslint-plugin-prettier/package.json"(exports, module) {
    module.exports = {
      name: "eslint-plugin-prettier",
      version: "5.1.3",
      description: "Runs prettier as an eslint rule",
      repository: "git+https://github.com/prettier/eslint-plugin-prettier.git",
      homepage: "https://github.com/prettier/eslint-plugin-prettier#readme",
      author: "Teddy Katz",
      contributors: [
        "JounQin (https://github.com/JounQin) <admin@1stg.me>"
      ],
      funding: "https://opencollective.com/eslint-plugin-prettier",
      license: "MIT",
      packageManager: "pnpm@7.33.5",
      engines: {
        node: "^14.18.0 || >=16.0.0"
      },
      main: "eslint-plugin-prettier.js",
      exports: {
        ".": {
          types: "./eslint-plugin-prettier.d.ts",
          default: "./eslint-plugin-prettier.js"
        },
        "./recommended": {
          types: "./recommended.d.ts",
          default: "./recommended.js"
        },
        "./package.json": "./package.json"
      },
      types: "eslint-plugin-prettier.d.ts",
      files: [
        "eslint-plugin-prettier.d.ts",
        "eslint-plugin-prettier.js",
        "recommended.d.ts",
        "recommended.js",
        "worker.js"
      ],
      keywords: [
        "eslint",
        "eslintplugin",
        "eslint-plugin",
        "prettier"
      ],
      peerDependencies: {
        "@types/eslint": ">=8.0.0",
        eslint: ">=8.0.0",
        "eslint-config-prettier": "*",
        prettier: ">=3.0.0"
      },
      peerDependenciesMeta: {
        "@types/eslint": {
          optional: true
        },
        "eslint-config-prettier": {
          optional: true
        }
      },
      dependencies: {
        "prettier-linter-helpers": "^1.0.0",
        synckit: "^0.8.6"
      },
      devDependencies: {
        "@1stg/remark-preset": "^2.0.0",
        "@changesets/changelog-github": "^0.5.0",
        "@changesets/cli": "^2.27.1",
        "@commitlint/config-conventional": "^18.4.3",
        "@eslint-community/eslint-plugin-eslint-comments": "^4.1.0",
        "@eslint/js": "^8.56.0",
        "@graphql-eslint/eslint-plugin": "^3.20.1",
        "@prettier/plugin-pug": "^3.0.0",
        "@types/eslint": "^8.56.0",
        "@types/prettier-linter-helpers": "^1.0.4",
        commitlint: "^18.4.3",
        eslint: "^8.56.0",
        "eslint-config-prettier": "^9.1.0",
        "eslint-formatter-friendly": "^7.0.0",
        "eslint-mdx": "^2.3.0",
        "eslint-plugin-eslint-plugin": "^5.2.1",
        "eslint-plugin-mdx": "^2.3.0",
        "eslint-plugin-n": "^16.5.0",
        "eslint-plugin-prettier": "link:.",
        "eslint-plugin-pug": "^1.2.5",
        "eslint-plugin-svelte": "^2.35.1",
        "eslint-plugin-svelte3": "^4.0.0",
        graphql: "^16.8.1",
        "lint-staged": "^15.2.0",
        mocha: "^10.2.0",
        prettier: "^3.1.1",
        "prettier-plugin-pkg": "^0.18.0",
        "prettier-plugin-svelte": "^3.1.2",
        "simple-git-hooks": "^2.9.0",
        svelte: "^4.2.8",
        "vue-eslint-parser": "^9.3.2"
      },
      scripts: {
        check: "prettier --check . && pnpm lint",
        format: "prettier --write . && pnpm lint --fix",
        lint: "eslint . --cache -f friendly --max-warnings 10",
        release: "pnpm check && pnpm test && changeset publish",
        test: "pnpm lint && mocha"
      }
    };
  }
});

// browser-external:node:crypto
var require_node_crypto = __commonJS({
  "browser-external:node:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:crypto" has been externalized for browser compatibility. Cannot access "node:crypto.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:fs
var require_node_fs = __commonJS({
  "browser-external:node:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:fs" has been externalized for browser compatibility. Cannot access "node:fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:module
var require_node_module = __commonJS({
  "browser-external:node:module"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:module" has been externalized for browser compatibility. Cannot access "node:module.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:path
var require_node_path = __commonJS({
  "browser-external:node:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:path" has been externalized for browser compatibility. Cannot access "node:path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:url
var require_node_url = __commonJS({
  "browser-external:node:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:url" has been externalized for browser compatibility. Cannot access "node:url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:worker_threads
var require_node_worker_threads = __commonJS({
  "browser-external:node:worker_threads"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:worker_threads" has been externalized for browser compatibility. Cannot access "node:worker_threads.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@pkgr/core/lib/index.cjs
var require_lib = __commonJS({
  "node_modules/@pkgr/core/lib/index.cjs"(exports) {
    "use strict";
    var node_module = require_node_module();
    var fs = require_node_fs();
    var path = require_node_path();
    var import_meta = {};
    var CWD = process.cwd();
    var cjsRequire = typeof __require === "undefined" ? node_module.createRequire(import_meta.url) : __require;
    var EXTENSIONS = [".ts", ".tsx", ...Object.keys(cjsRequire.extensions)];
    var tryPkg = (pkg) => {
      try {
        return cjsRequire.resolve(pkg);
      } catch (e) {
      }
    };
    var isPkgAvailable = (pkg) => !!tryPkg(pkg);
    var tryFile = (filePath, includeDir = false) => {
      if (typeof filePath === "string") {
        return fs.existsSync(filePath) && (includeDir || fs.statSync(filePath).isFile()) ? filePath : "";
      }
      for (const file of filePath != null ? filePath : []) {
        if (tryFile(file, includeDir)) {
          return file;
        }
      }
      return "";
    };
    var tryExtensions = (filepath, extensions = EXTENSIONS) => {
      const ext = [...extensions, ""].find((ext2) => tryFile(filepath + ext2));
      return ext == null ? "" : filepath + ext;
    };
    var findUp = (searchEntry, searchFileOrIncludeDir, includeDir) => {
      console.assert(path.isAbsolute(searchEntry));
      if (!tryFile(searchEntry, true) || searchEntry !== CWD && !searchEntry.startsWith(CWD + path.sep)) {
        return "";
      }
      searchEntry = path.resolve(
        fs.statSync(searchEntry).isDirectory() ? searchEntry : path.resolve(searchEntry, "..")
      );
      const isSearchFile = typeof searchFileOrIncludeDir === "string";
      const searchFile = isSearchFile ? searchFileOrIncludeDir : "package.json";
      do {
        const searched = tryFile(
          path.resolve(searchEntry, searchFile),
          isSearchFile && includeDir
        );
        if (searched) {
          return searched;
        }
        searchEntry = path.resolve(searchEntry, "..");
      } while (searchEntry === CWD || searchEntry.startsWith(CWD + path.sep));
      return "";
    };
    exports.CWD = CWD;
    exports.EXTENSIONS = EXTENSIONS;
    exports.cjsRequire = cjsRequire;
    exports.findUp = findUp;
    exports.isPkgAvailable = isPkgAvailable;
    exports.tryExtensions = tryExtensions;
    exports.tryFile = tryFile;
    exports.tryPkg = tryPkg;
  }
});

// node_modules/synckit/lib/index.cjs
var require_lib2 = __commonJS({
  "node_modules/synckit/lib/index.cjs"(exports) {
    "use strict";
    var node_crypto = require_node_crypto();
    var fs = require_node_fs();
    var node_module = require_node_module();
    var path = require_node_path();
    var node_url = require_node_url();
    var node_worker_threads = require_node_worker_threads();
    var core = require_lib();
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var import_meta = {};
    var TsRunner = {
      // https://github.com/TypeStrong/ts-node
      TsNode: "ts-node",
      // https://github.com/egoist/esbuild-register
      EsbuildRegister: "esbuild-register",
      // https://github.com/folke/esbuild-runner
      EsbuildRunner: "esbuild-runner",
      // https://github.com/swc-project/swc-node/tree/master/packages/register
      SWC: "swc",
      // https://github.com/esbuild-kit/tsx
      TSX: "tsx"
    };
    var {
      SYNCKIT_BUFFER_SIZE,
      SYNCKIT_TIMEOUT,
      SYNCKIT_EXEC_ARGV,
      SYNCKIT_TS_RUNNER,
      SYNCKIT_GLOBAL_SHIMS,
      NODE_OPTIONS
    } = process.env;
    var DEFAULT_BUFFER_SIZE = SYNCKIT_BUFFER_SIZE ? +SYNCKIT_BUFFER_SIZE : void 0;
    var DEFAULT_TIMEOUT = SYNCKIT_TIMEOUT ? +SYNCKIT_TIMEOUT : void 0;
    var DEFAULT_WORKER_BUFFER_SIZE = DEFAULT_BUFFER_SIZE || 1024;
    var DEFAULT_EXEC_ARGV = (SYNCKIT_EXEC_ARGV == null ? void 0 : SYNCKIT_EXEC_ARGV.split(",")) || [];
    var DEFAULT_TS_RUNNER = SYNCKIT_TS_RUNNER;
    var DEFAULT_GLOBAL_SHIMS = ["1", "true"].includes(
      SYNCKIT_GLOBAL_SHIMS
    );
    var DEFAULT_GLOBAL_SHIMS_PRESET = [
      {
        moduleName: "node-fetch",
        globalName: "fetch"
      },
      {
        moduleName: "node:perf_hooks",
        globalName: "performance",
        named: "performance"
      }
    ];
    var MTS_SUPPORTED_NODE_VERSION = 16;
    var syncFnCache = /* @__PURE__ */ new Map();
    function extractProperties(object) {
      if (object && typeof object === "object") {
        const properties = {};
        for (const key in object) {
          properties[key] = object[key];
        }
        return properties;
      }
    }
    function createSyncFn(workerPath, bufferSizeOrOptions, timeout) {
      if (!path.isAbsolute(workerPath)) {
        throw new Error("`workerPath` must be absolute");
      }
      const cachedSyncFn = syncFnCache.get(workerPath);
      if (cachedSyncFn) {
        return cachedSyncFn;
      }
      const syncFn = startWorkerThread(
        workerPath,
        /* istanbul ignore next */
        typeof bufferSizeOrOptions === "number" ? { bufferSize: bufferSizeOrOptions, timeout } : bufferSizeOrOptions
      );
      syncFnCache.set(workerPath, syncFn);
      return syncFn;
    }
    var cjsRequire = typeof __require === "undefined" ? node_module.createRequire(import_meta.url) : (
      /* istanbul ignore next */
      __require
    );
    var dataUrl = (code) => new URL(`data:text/javascript,${encodeURIComponent(code)}`);
    var isFile = (path2) => {
      var _a;
      try {
        return !!((_a = fs.statSync(path2, { throwIfNoEntry: false })) == null ? void 0 : _a.isFile());
      } catch (e) {
        return false;
      }
    };
    var setupTsRunner = (workerPath, { execArgv, tsRunner }) => {
      let ext = path.extname(workerPath);
      if (!/[/\\]node_modules[/\\]/.test(workerPath) && (!ext || /^\.[cm]?js$/.test(ext))) {
        const workPathWithoutExt = ext ? workerPath.slice(0, -ext.length) : workerPath;
        let extensions;
        switch (ext) {
          case ".cjs": {
            extensions = [".cts", ".cjs"];
            break;
          }
          case ".mjs": {
            extensions = [".mts", ".mjs"];
            break;
          }
          default: {
            extensions = [".ts", ".js"];
            break;
          }
        }
        const found = core.tryExtensions(workPathWithoutExt, extensions);
        let differentExt;
        if (found && (!ext || (differentExt = found !== workPathWithoutExt))) {
          workerPath = found;
          if (differentExt) {
            ext = path.extname(workerPath);
          }
        }
      }
      const isTs = /\.[cm]?ts$/.test(workerPath);
      let jsUseEsm = workerPath.endsWith(".mjs");
      let tsUseEsm = workerPath.endsWith(".mts");
      if (isTs) {
        if (!tsUseEsm) {
          const pkg = core.findUp(workerPath);
          if (pkg) {
            tsUseEsm = cjsRequire(pkg).type === "module";
          }
        }
        if (tsRunner == null && core.isPkgAvailable(TsRunner.TsNode)) {
          tsRunner = TsRunner.TsNode;
        }
        switch (tsRunner) {
          case TsRunner.TsNode: {
            if (tsUseEsm) {
              if (!execArgv.includes("--loader")) {
                execArgv = ["--loader", `${TsRunner.TsNode}/esm`, ...execArgv];
              }
            } else if (!execArgv.includes("-r")) {
              execArgv = ["-r", `${TsRunner.TsNode}/register`, ...execArgv];
            }
            break;
          }
          case TsRunner.EsbuildRegister: {
            if (!execArgv.includes("-r")) {
              execArgv = ["-r", TsRunner.EsbuildRegister, ...execArgv];
            }
            break;
          }
          case TsRunner.EsbuildRunner: {
            if (!execArgv.includes("-r")) {
              execArgv = ["-r", `${TsRunner.EsbuildRunner}/register`, ...execArgv];
            }
            break;
          }
          case TsRunner.SWC: {
            if (!execArgv.includes("-r")) {
              execArgv = ["-r", `@${TsRunner.SWC}-node/register`, ...execArgv];
            }
            break;
          }
          case TsRunner.TSX: {
            if (!execArgv.includes("--loader")) {
              execArgv = ["--loader", TsRunner.TSX, ...execArgv];
            }
            break;
          }
          default: {
            throw new Error(`Unknown ts runner: ${String(tsRunner)}`);
          }
        }
      } else if (!jsUseEsm) {
        const pkg = core.findUp(workerPath);
        if (pkg) {
          jsUseEsm = cjsRequire(pkg).type === "module";
        }
      }
      if (process.versions.pnp) {
        const nodeOptions = NODE_OPTIONS == null ? void 0 : NODE_OPTIONS.split(/\s+/);
        let pnpApiPath;
        try {
          pnpApiPath = cjsRequire.resolve("pnpapi");
        } catch (e) {
        }
        if (pnpApiPath && !(nodeOptions == null ? void 0 : nodeOptions.some(
          (option, index) => ["-r", "--require"].includes(option) && pnpApiPath === cjsRequire.resolve(nodeOptions[index + 1])
        )) && !execArgv.includes(pnpApiPath)) {
          execArgv = ["-r", pnpApiPath, ...execArgv];
          const pnpLoaderPath = path.resolve(pnpApiPath, "../.pnp.loader.mjs");
          if (isFile(pnpLoaderPath)) {
            const experimentalLoader = node_url.pathToFileURL(pnpLoaderPath).toString();
            execArgv = ["--experimental-loader", experimentalLoader, ...execArgv];
          }
        }
      }
      return {
        ext,
        isTs,
        jsUseEsm,
        tsRunner,
        tsUseEsm,
        workerPath,
        execArgv
      };
    };
    var md5Hash = (text) => node_crypto.createHash("md5").update(text).digest("hex");
    var encodeImportModule = (moduleNameOrGlobalShim, type = "import") => {
      const { moduleName, globalName, named, conditional } = typeof moduleNameOrGlobalShim === "string" ? { moduleName: moduleNameOrGlobalShim } : moduleNameOrGlobalShim;
      const importStatement = type === "import" ? `import${globalName ? " " + (named === null ? "* as " + globalName : (named == null ? void 0 : named.trim()) ? `{${named}}` : globalName) + " from" : ""} '${path.isAbsolute(moduleName) ? String(node_url.pathToFileURL(moduleName)) : moduleName}'` : `${globalName ? "const " + ((named == null ? void 0 : named.trim()) ? `{${named}}` : globalName) + "=" : ""}require('${moduleName.replace(/\\/g, "\\\\")}')`;
      if (!globalName) {
        return importStatement;
      }
      const overrideStatement = `globalThis.${globalName}=${(named == null ? void 0 : named.trim()) ? named : globalName}`;
      return importStatement + (conditional === false ? `;${overrideStatement}` : `;if(!globalThis.${globalName})${overrideStatement}`);
    };
    var _generateGlobals = (globalShims, type) => globalShims.reduce(
      (acc, shim) => `${acc}${acc ? ";" : ""}${encodeImportModule(shim, type)}`,
      ""
    );
    var globalsCache = /* @__PURE__ */ new Map();
    var tmpdir;
    var _dirname = typeof __dirname === "undefined" ? path.dirname(node_url.fileURLToPath(import_meta.url)) : (
      /* istanbul ignore next */
      __dirname
    );
    var generateGlobals = (workerPath, globalShims, type = "import") => {
      const cached = globalsCache.get(workerPath);
      if (cached) {
        const [content2, filepath2] = cached;
        if (type === "require" && !filepath2 || type === "import" && filepath2 && isFile(filepath2)) {
          return content2;
        }
      }
      const globals = _generateGlobals(globalShims, type);
      let content = globals;
      let filepath;
      if (type === "import") {
        if (!tmpdir) {
          tmpdir = path.resolve(core.findUp(_dirname), "../node_modules/.synckit");
        }
        fs.mkdirSync(tmpdir, { recursive: true });
        filepath = path.resolve(tmpdir, md5Hash(workerPath) + ".mjs");
        content = encodeImportModule(filepath);
        fs.writeFileSync(filepath, globals);
      }
      globalsCache.set(workerPath, [content, filepath]);
      return content;
    };
    function startWorkerThread(workerPath, {
      bufferSize = DEFAULT_WORKER_BUFFER_SIZE,
      timeout = DEFAULT_TIMEOUT,
      execArgv = DEFAULT_EXEC_ARGV,
      tsRunner = DEFAULT_TS_RUNNER,
      transferList = [],
      globalShims = DEFAULT_GLOBAL_SHIMS
    } = {}) {
      const { port1: mainPort, port2: workerPort } = new node_worker_threads.MessageChannel();
      const {
        isTs,
        ext,
        jsUseEsm,
        tsUseEsm,
        tsRunner: finalTsRunner,
        workerPath: finalWorkerPath,
        execArgv: finalExecArgv
      } = setupTsRunner(workerPath, { execArgv, tsRunner });
      const workerPathUrl = node_url.pathToFileURL(finalWorkerPath);
      if (/\.[cm]ts$/.test(finalWorkerPath)) {
        const isTsxSupported = !tsUseEsm || Number.parseFloat(process.versions.node) >= MTS_SUPPORTED_NODE_VERSION;
        if (!finalTsRunner) {
          throw new Error("No ts runner specified, ts worker path is not supported");
        } else if ([
          // https://github.com/egoist/esbuild-register/issues/79
          TsRunner.EsbuildRegister,
          // https://github.com/folke/esbuild-runner/issues/67
          TsRunner.EsbuildRunner,
          // https://github.com/swc-project/swc-node/issues/667
          TsRunner.SWC,
          .../* istanbul ignore next */
          isTsxSupported ? [] : [TsRunner.TSX]
        ].includes(finalTsRunner)) {
          throw new Error(
            `${finalTsRunner} is not supported for ${ext} files yet` + /* istanbul ignore next */
            (isTsxSupported ? ", you can try [tsx](https://github.com/esbuild-kit/tsx) instead" : "")
          );
        }
      }
      const finalGlobalShims = (globalShims === true ? DEFAULT_GLOBAL_SHIMS_PRESET : Array.isArray(globalShims) ? globalShims : []).filter(({ moduleName }) => core.isPkgAvailable(moduleName));
      const useGlobals = finalGlobalShims.length > 0;
      const useEval = isTs ? !tsUseEsm : !jsUseEsm && useGlobals;
      const worker = new node_worker_threads.Worker(
        jsUseEsm && useGlobals || tsUseEsm && finalTsRunner === TsRunner.TsNode ? dataUrl(
          `${generateGlobals(
            finalWorkerPath,
            finalGlobalShims
          )};import '${String(workerPathUrl)}'`
        ) : useEval ? `${generateGlobals(
          finalWorkerPath,
          finalGlobalShims,
          "require"
        )};${encodeImportModule(finalWorkerPath, "require")}` : workerPathUrl,
        {
          eval: useEval,
          workerData: { workerPort },
          transferList: [workerPort, ...transferList],
          execArgv: finalExecArgv
        }
      );
      let nextID = 0;
      const syncFn = (...args) => {
        const id = nextID++;
        const sharedBuffer = new SharedArrayBuffer(bufferSize);
        const sharedBufferView = new Int32Array(sharedBuffer);
        const msg = { sharedBuffer, id, args };
        worker.postMessage(msg);
        const status = Atomics.wait(sharedBufferView, 0, 0, timeout);
        if (!["ok", "not-equal"].includes(status)) {
          throw new Error("Internal error: Atomics.wait() failed: " + status);
        }
        const {
          id: id2,
          result,
          error,
          properties
        } = node_worker_threads.receiveMessageOnPort(mainPort).message;
        if (id !== id2) {
          throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
        }
        if (error) {
          throw Object.assign(error, properties);
        }
        return result;
      };
      worker.unref();
      return syncFn;
    }
    function runAsWorker(fn) {
      if (!node_worker_threads.workerData) {
        return;
      }
      const { workerPort } = node_worker_threads.workerData;
      node_worker_threads.parentPort.on(
        "message",
        ({ sharedBuffer, id, args }) => {
          (() => __async(this, null, function* () {
            const sharedBufferView = new Int32Array(sharedBuffer);
            let msg;
            try {
              msg = { id, result: yield fn(...args) };
            } catch (error) {
              msg = { id, error, properties: extractProperties(error) };
            }
            workerPort.postMessage(msg);
            Atomics.add(sharedBufferView, 0, 1);
            Atomics.notify(sharedBufferView, 0);
          }))();
        }
      );
    }
    exports.DEFAULT_BUFFER_SIZE = DEFAULT_BUFFER_SIZE;
    exports.DEFAULT_EXEC_ARGV = DEFAULT_EXEC_ARGV;
    exports.DEFAULT_GLOBAL_SHIMS = DEFAULT_GLOBAL_SHIMS;
    exports.DEFAULT_GLOBAL_SHIMS_PRESET = DEFAULT_GLOBAL_SHIMS_PRESET;
    exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    exports.DEFAULT_TS_RUNNER = DEFAULT_TS_RUNNER;
    exports.DEFAULT_WORKER_BUFFER_SIZE = DEFAULT_WORKER_BUFFER_SIZE;
    exports.MTS_SUPPORTED_NODE_VERSION = MTS_SUPPORTED_NODE_VERSION;
    exports.TsRunner = TsRunner;
    exports._generateGlobals = _generateGlobals;
    exports.createSyncFn = createSyncFn;
    exports.encodeImportModule = encodeImportModule;
    exports.extractProperties = extractProperties;
    exports.generateGlobals = generateGlobals;
    exports.isFile = isFile;
    exports.runAsWorker = runAsWorker;
  }
});

// node_modules/eslint-plugin-prettier/eslint-plugin-prettier.js
var require_eslint_plugin_prettier = __commonJS({
  "node_modules/eslint-plugin-prettier/eslint-plugin-prettier.js"(exports, module) {
    var {
      showInvisibles,
      generateDifferences
    } = require_prettier_linter_helpers();
    var { name, version } = require_package();
    var { INSERT, DELETE, REPLACE } = generateDifferences;
    var prettierFormat;
    function reportDifference(context, difference) {
      const { operation, offset, deleteText = "", insertText = "" } = difference;
      const range = (
        /** @type {Range} */
        [offset, offset + deleteText.length]
      );
      const [start, end] = range.map(
        (index) => (context.sourceCode ?? context.getSourceCode()).getLocFromIndex(index)
      );
      context.report({
        messageId: operation,
        data: {
          deleteText: showInvisibles(deleteText),
          insertText: showInvisibles(insertText)
        },
        loc: { start, end },
        fix: (fixer) => fixer.replaceTextRange(range, insertText)
      });
    }
    var eslintPluginPrettier = {
      meta: { name, version },
      configs: {
        recommended: {
          extends: ["prettier"],
          plugins: ["prettier"],
          rules: {
            "prettier/prettier": "error",
            "arrow-body-style": "off",
            "prefer-arrow-callback": "off"
          }
        }
      },
      rules: {
        prettier: {
          meta: {
            docs: {
              url: "https://github.com/prettier/eslint-plugin-prettier#options"
            },
            type: "layout",
            fixable: "code",
            schema: [
              // Prettier options:
              {
                type: "object",
                properties: {},
                additionalProperties: true
              },
              {
                type: "object",
                properties: {
                  usePrettierrc: { type: "boolean" },
                  fileInfoOptions: {
                    type: "object",
                    properties: {},
                    additionalProperties: true
                  }
                },
                additionalProperties: true
              }
            ],
            messages: {
              [INSERT]: "Insert `{{ insertText }}`",
              [DELETE]: "Delete `{{ deleteText }}`",
              [REPLACE]: "Replace `{{ deleteText }}` with `{{ insertText }}`"
            }
          },
          create(context) {
            const usePrettierrc = !context.options[1] || context.options[1].usePrettierrc !== false;
            const fileInfoOptions = context.options[1] && context.options[1].fileInfoOptions || {};
            const sourceCode = context.sourceCode ?? context.getSourceCode();
            const filepath = context.filename ?? context.getFilename();
            const onDiskFilepath = context.physicalFilename ?? context.getPhysicalFilename();
            const source = sourceCode.text;
            return {
              Program() {
                var _a;
                if (!prettierFormat) {
                  prettierFormat = require_lib2().createSyncFn(
                    __require.resolve("./worker")
                  );
                }
                const eslintPrettierOptions = context.options[0] || {};
                const parser = (_a = context.languageOptions) == null ? void 0 : _a.parser;
                let prettierSource;
                try {
                  prettierSource = prettierFormat(
                    source,
                    {
                      ...eslintPrettierOptions,
                      filepath,
                      onDiskFilepath,
                      parserMeta: parser && (parser.meta ?? {
                        name: parser.name,
                        version: parser.version
                      }),
                      parserPath: context.parserPath,
                      usePrettierrc
                    },
                    fileInfoOptions
                  );
                } catch (err) {
                  if (!(err instanceof SyntaxError)) {
                    throw err;
                  }
                  let message = "Parsing error: " + err.message;
                  const error = (
                    /** @type {SyntaxError & {codeFrame: string; loc: SourceLocation}} */
                    err
                  );
                  if (error.codeFrame) {
                    message = message.replace(`
${error.codeFrame}`, "");
                  }
                  if (error.loc) {
                    message = message.replace(/ \(\d+:\d+\)$/, "");
                  }
                  context.report({ message, loc: error.loc });
                  return;
                }
                if (prettierSource == null) {
                  return;
                }
                if (source !== prettierSource) {
                  const differences = generateDifferences(source, prettierSource);
                  for (const difference of differences) {
                    reportDifference(context, difference);
                  }
                }
              }
            };
          }
        }
      }
    };
    module.exports = eslintPluginPrettier;
  }
});
export default require_eslint_plugin_prettier();
//# sourceMappingURL=eslint-plugin-prettier.js.map
